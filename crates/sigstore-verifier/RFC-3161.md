# RFC 3161 Timestamp Verification - TODO

This document outlines the requirements for implementing RFC 3161 timestamp verification in the sigstore-verifier library.

## Status

**NOT IMPLEMENTED** - Postponed for future work

Currently, the library only supports bundles with Rekor transparency log entries. Bundles containing only RFC 3161 timestamps (e.g., GitHub Actions attestations) are explicitly rejected.

## Background

Sigstore bundles can use two different mechanisms for proving signing time:

1. **Rekor Transparency Log Entries** (Public Good infrastructure)
   - Uses integrated time from Rekor
   - Includes inclusion proof verification
   - Currently SUPPORTED

2. **RFC 3161 Timestamps** (GitHub Actions infrastructure)
   - Uses signed timestamps from Timestamp Authority (TSA)
   - Requires complex ASN.1/PKCS7 parsing
   - Currently NOT SUPPORTED

### Bundle Type Distribution

From sample analysis:
- GitHub Actions bundles: RFC3161 only (no Rekor)
- Public Good bundles: Rekor only (no RFC3161)

## What Gets Timestamped

**Critical Detail**: RFC 3161 timestamps in Sigstore bundles timestamp the **DSSE signature itself**, not the artifact. This is called "countersigning."

The verification must hash the signature bytes and verify they match the message imprint in the timestamp token.

## RFC 3161 Verification Requirements

### 1. Parse RFC 3161 Timestamp Response

The timestamp is a CMS SignedData structure containing:

```
TimeStampToken ::= ContentInfo
  ContentInfo ::= SEQUENCE {
    contentType OBJECT IDENTIFIER (id-signedData),
    content [0] EXPLICIT SignedData
  }

SignedData contains encapsulated TSTInfo:
  TSTInfo ::= SEQUENCE {
    version INTEGER,
    policy TSAPolicyId,
    messageImprint MessageImprint,      ← Hash of signature bytes
    serialNumber INTEGER,
    genTime GeneralizedTime,            ← The signing timestamp
    accuracy Accuracy OPTIONAL,
    ordering BOOLEAN DEFAULT FALSE,
    nonce INTEGER OPTIONAL,
    tsa [0] GeneralName OPTIONAL
  }

MessageImprint ::= SEQUENCE {
    hashAlgorithm AlgorithmIdentifier,  ← Usually SHA-256 or SHA-384
    hashedMessage OCTET STRING          ← Hash to verify
  }
```

### 2. Verify Timestamp Certificate Chain

Must verify the TSA certificate chain similar to Fulcio verification:

- Parse certificates from timestamp response (if embedded) or accept as parameter
- Build chain: leaf → intermediates → root
- Verify each certificate signature
- Verify certificate validity periods
- **Critical**: Verify leaf certificate EKU (Extended Key Usage):
  - Must be set to `TimeStamping` (OID: 1.3.6.1.5.5.7.3.8) ONLY
  - Extension must be marked as `critical` (per RFC 3161 §2.3)
- Verify EKU chaining for intermediates:
  - Can have no EKU (unrestricted)
  - Or must include `TimeStamping` or `Any`

### 3. Verify Message Imprint

This is the core verification that proves the timestamp is for this specific signature:

```rust
// Pseudocode
let signature_b64 = bundle.dsse_envelope.signatures[0].sig;
let signature_bytes = decode_base64(signature_b64)?;

// Extract from TSTInfo
let hash_algorithm = tstinfo.message_imprint.hash_algorithm;
let expected_hash = tstinfo.message_imprint.hashed_message;

// Compute hash of the DSSE signature bytes
let computed_hash = match hash_algorithm {
    SHA256 => sha256(signature_bytes),
    SHA384 => sha384(signature_bytes),
    _ => return Err(UnsupportedHashAlgorithm),
};

// Verify they match
if computed_hash != expected_hash {
    return Err(MessageImprintMismatch);
}
```

### 4. Verify PKCS#7 Signature

- Parse the PKCS#7/CMS SignedData structure
- Verify the cryptographic signature on the timestamp token
- Use the TSA certificate public key for verification

### 5. Extract Signing Time

- Extract `genTime` field from TSTInfo
- Parse as GeneralizedTime (format: YYYYMMDDHHMMSSsZ)
- Convert to DateTime<Utc>
- Use this as the signing time for certificate validity checking

### 6. Optional Verifications

- Verify nonce (if present - usually not in Sigstore)
- Verify policy OID (if specified)
- Verify TSA certificate identifier

## Implementation Requirements

### Dependencies

Need to add Rust crates for ASN.1/PKCS7 parsing:

```toml
# Cargo.toml additions
cms = "0.2"        # CMS/PKCS7 structures
der = "0.7"        # DER encoding/decoding
x509-cert = "0.2"  # X.509 certificate parsing
```

### Code Structure

```
src/parser/timestamp.rs
  - parse_rfc3161_timestamp(der: &[u8]) -> Rfc3161TimestampInfo
  - parse_tstinfo(der: &[u8]) -> TSTInfo
  - extract_signing_time(tstinfo: &TSTInfo) -> DateTime<Utc>

src/verifier/timestamp.rs
  - verify_rfc3161_timestamp(
      timestamp: &[u8],
      signature_bytes: &[u8],
      tsa_chain: &CertificateChain
    ) -> Result<DateTime<Utc>, TimestampError>
  - verify_message_imprint(...)
  - verify_tsa_certificate_chain(...)
  - verify_pkcs7_signature(...)

src/verifier/certificate.rs
  - verify_tsa_certificate_eku(cert: &X509Certificate) -> Result<(), CertificateError>
```

### TSA Certificate Chain Sources

For GitHub Actions TSA:
- Root: CN=TSA Root, O=GitHub, Inc.
- Intermediate: CN=TSA intermediate, O=GitHub, Inc.
- Leaf: CN=TSA Timestamping, O=GitHub, Inc.

The chain may be:
1. Embedded in the timestamp response
2. Provided by caller (recommended approach for this library)
3. Fetched from GitHub's TSA infrastructure

### Integration into Main Verification

In `src/lib.rs`, the workflow would become:

```rust
// Step 2: Get signing time (from RFC3161 or integrated time)
let signing_time = get_signing_time(bundle, tsa_chain_option)?;

// If RFC3161, verify the timestamp includes the signature
if has_rfc3161_timestamp(bundle) {
    let signature_bytes = decode_base64(&bundle.dsse_envelope.signatures[0].sig)?;
    verify_rfc3161_timestamp(
        &bundle.verification_material.timestamp_verification_data,
        &signature_bytes,
        tsa_chain_option.ok_or(MissingTSAChain)?
    )?;
}
```

## Testing Strategy

### Test Cases Needed

1. **Valid RFC 3161 timestamp**
   - Parse and extract signing time
   - Verify message imprint matches signature
   - Verify TSA certificate chain

2. **Invalid message imprint**
   - Timestamp with wrong hash should fail

3. **Invalid TSA certificate**
   - Wrong EKU should fail
   - EKU not marked critical should fail
   - Expired certificate should fail

4. **Hash algorithm support**
   - Test SHA-256
   - Test SHA-384
   - Reject unsupported algorithms

5. **Integration tests**
   - Use real GitHub Actions bundle samples
   - Verify complete workflow

## References

- RFC 3161: Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP)
  https://datatracker.ietf.org/doc/html/rfc3161

- Sigstore Timestamp Authority implementation:
  https://github.com/sigstore/timestamp-authority

- Sigstore Go verification implementation:
  https://github.com/sigstore/sigstore-go/blob/main/pkg/verify/tsa.go
  https://github.com/sigstore/sigstore-go/blob/main/pkg/root/timestamping_authority.go

- Sigstore documentation on timestamps:
  https://docs.sigstore.dev/cosign/verifying/timestamps/

- Sigstore bundle format specification:
  https://docs.sigstore.dev/about/bundle/

## Estimated Effort

**6-8 hours** of implementation time:
- ASN.1/PKCS7 parsing: 3-4 hours
- Verification logic: 2-3 hours
- Testing and integration: 1-2 hours

This is complex due to:
- ASN.1 structure parsing
- PKCS#7/CMS handling
- Certificate chain verification with EKU constraints
- Integration with existing verification flow
